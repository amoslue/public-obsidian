#dijkstra 
时间复杂度：
![[Pasted image 20240321134013.png]]
code:
![[Pasted image 20240321135857.png]]
explanation:
![[Pasted image 20240321141136.png]]![[Pasted image 20240321141148.png]]
![[Pasted image 20240321141111.png]]
vid:
https://www.youtube.com/watch?v=CL1byLngb5Q
code:
https://leetcode.cn/problems/network-delay-time/submissions/
```
```
```java
class Solution {

// times = [[2,1,1],[2,3,1],[3,4,1]], n = 4 (total nodes), k = 2 (start ponit)

public int networkDelayTime(int[][] times, int n, int k) {

List<int[]>[] graph = new List[n+1];

for (int i =1;i<=n;i++){

graph[i] = new ArrayList<int[]>();

}

for (int[] t:times){

int from = t[0], to = t[1], w = t[2];

graph[from].add(new int[]{to, w});

}

  

PriorityQueue<int[]> heap = new PriorityQueue<>((a,b)->a[0]-b[0]);

// {distance, current node}

heap.add(new int[]{0,k});

// map<node, dis> (visited or not)

Map <Integer,Integer> map = new HashMap<>();

while (heap.size()!=0){

int[] cur = heap.poll();

int dis = cur[0], node = cur[1];

if (map.containsKey(node)) continue;

map.put(node, dis);

  

for (int[] g:graph[node]){

int toNode = g[0];

int weight = g[1];

if (map.containsKey(toNode)) continue;

heap.add(new int[]{dis+weight,toNode});

}

}

if (map.size()<n) return -1;

int ret = 0;

for (int i: map.values()) 
	ret = Math.max(ret, i);
return ret;
}

}
```

#leetcode #djikst 
[dj+dfs](https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/solutions/1097204/python-java-dijkstra-cached-dfs-clean-concise/?envType=list&envId=53js48ke)
https://leetcode.com/list/53js48ke/