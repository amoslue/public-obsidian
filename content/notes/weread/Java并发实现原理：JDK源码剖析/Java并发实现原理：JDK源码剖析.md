---
doc_type: weread-highlights-reviews
bookId: "31186368"
author: 余春龙
cover: https://cdn.weread.qq.com/weread/cover/72/YueWen_31186368/t7_YueWen_31186368.jpg
reviewCount: 0
noteCount: 34
isbn: 9787121379727
category: 计算机-编程设计
lastReadDate: 2021-05-07
---
# 元数据
> [!abstract] Java并发实现原理：JDK源码剖析
> - ![ Java并发实现原理：JDK源码剖析|200](https://cdn.weread.qq.com/weread/cover/72/YueWen_31186368/t7_YueWen_31186368.jpg)
> - 书名： Java并发实现原理：JDK源码剖析
> - 作者： 余春龙
> - 简介： 本书全面而系统地剖析了Java Concurrent包中的每一个部分，对并发的实现原理进行了深刻的探讨。全书分为8章，第1章从最基础的多线程知识讲起，理清多线程中容易误解的知识点，探究背后的原理，包括内存重排序、happen-before、内存屏障等；第2~8章，从简单到复杂，逐个剖析Concurrent包的每个部分，包括原子类、锁、同步工具类、并发容器、线程池、ForkJoinPool、CompletableFuture共7个部分。本书遵循层层递进的逻辑，后一章建立在前一章的知识点基础之上，建议读者由浅入深，逐步深入阅读。本书适合有一定Java开发经验的工程师、架构师阅读。通过本书，读者可以对多线程编程形成一个“深刻而直观”的认识，而不是再仅仅停留在概念和理论层面。
> - 出版时间 2020-03-01 00:00:00
> - ISBN： 9787121379727
> - 分类： 计算机-编程设计
> - 出版社： 电子工业出版社

# 高亮划线

## 1.3 synchronized关键字


- 📌 这间接回答了关于synchronized 的常见问题：一个静态成员函数和一个非静态成员函数，都加了synchronized关键字，分别被两个线程调用，它们是否互斥？很显然，因为是两把不同的锁，所以不会互斥。 
    - ⏱ 2021-05-05 14:19:39 
## 1.5 volatile关键字


- 📌 （1）分配一块内存。（2）在内存上初始化成员变量。（3）把instance引用指向内存。 
    - ⏱ 2021-05-05 15:38:21 
## 1.6 JMM与happen-before


- 📌 （1）编译器重排序。对于没有先后依赖关系的语句，编译器可以重新调整语句的执行顺序。（2）CPU指令重排序。在指令级别，让没有依赖关系的多条指令并行。（3）CPU内存重排序。CPU有自己的缓存，指令的执行顺序和写入主内存的顺序不完全一致。 
    - ⏱ 2021-05-05 15:48:34 

- 📌 但此时X=1还在自己的Store Buffer 
    - ⏱ 2021-05-05 15:48:40 

- 📌 只要操作之间没有数据依赖性，如上例所示，编译器和CPU都可以任意重排序，因为执行结果不会改变，代码看起来就像是完全串行地一行行从头执行到尾 
    - ⏱ 2021-05-05 15:49:46 

- 📌 如果A happen-before B，意味着A的执行结果必须对B可见，也就是保证跨线程的内存可见性。A happen before B不代表A一定在B之前执行。因为，对于多线程程序而言，两个操作的执行顺序是不确定的。happen-before只确保如果A在B之前执行，则A的执行结果必须对B可见。 
    - ⏱ 2021-05-05 15:51:21 

- 📌 volatile 变量不能重排序；非volatile 变量可以任意重排序。 
    - ⏱ 2021-05-05 15:53:05 

- 📌 禁止volatile变量写入和非volatile变量写入的重排序 
    - ⏱ 2021-05-05 15:59:21 
## 1.8 final关键字


- 📌 ① 分配一块内存；② 在内存上初始化i=1，j=2；③ 把obj指向这块内存。 
    - ⏱ 2021-05-05 21:11:21 

- 📌 办法1：给i，j都加上volatile关键字。办法2：为read/write函数都加上synchronized关键字。 
    - ⏱ 2021-05-05 21:11:43 

- 📌 如果i，j只需要初始化一次，则后续值就不会再变了，还有办法3，为其加上final关键字。 
    - ⏱ 2021-05-05 21:12:07 
## 2.1 AtomicInteger和AtomicLong


- 📌 synchronized关键字，以及后面要讲的ReentrantLock都是悲观锁的典型例子。 
    - ⏱ 2021-05-07 18:45:46 

- 📌 所以读操作之前不上锁。等到写操作的时候，再判断数据在此期间是否被其他线程修改了 
    - ⏱ 2021-05-07 18:46:00 

- 📌 修改了，就把数据重新读出来，重复该过程；如果没有被修改，就写回去。判断数据是否被修改，同时写回新值，这两个操作要合成一个原子操作，也就是CAS（Compare And Set）。 
    - ⏱ 2021-05-07 18:46:11 
## 2.2 AtomicBoolean和AtomicReference


- 📌 也就是要实现compare和set两个操作合在一起的原子性，而这也正是CAS提供的功能。上面的代码，就变成： 
    - ⏱ 2021-05-07 18:59:22 
## 2.3 AtomicStampedReference和AtomicMarkableReference


- 📌 AtomicMarkableReference与AtomicStampedReference原理类似，只是Pair里面的版本号是boolean类型的，而不是整型的累加变量，如下所示。 
    - ⏱ 2021-05-07 19:02:48 

- 📌 因为是boolean类型，只能有true、false 两个版本号，所以并不能完全避免ABA问题，只是降低了ABA发生的概率。 
    - ⏱ 2021-05-07 19:02:35 
## 2.4 AtomicIntegerFieldUpdater、AtomicLongFieldUpdater和AtomicReferenceFieldUpdater


- 📌 但如果是一个已经有的类，在不能更改其源代码的情况下，要想实现对其成员变量的原子操作，就需要AtomicIntegerFieldUpdater、AtomicLongFieldUpdater 和AtomicReferenceFieldUpdater 
    - ⏱ 2021-05-07 19:05:07 

- 📌 静态函数传入的是要修改的类（不是对象）和对应的成员变量的名字，内部通过反射拿到这个类的成员变量，然后包装成一个AtomicIntegerFieldUpdater对象。所以，这个对象表示的是类的某个成员，而不是对象的成员变量。 
    - ⏱ 2021-05-07 19:20:24 
## 第3章 Lock与Condition


- 📌 “可重入锁”是指当一个线程调用object.lock（）拿到锁，进入互斥区后，再次调用object.lock（），仍然可以拿到该锁。很显然，通常的锁都要设计成可重入的，否则就会发生死锁 
    - ⏱ 2021-05-07 19:22:09 

- 📌 synchronized关键字，同样是可重入锁 
    - ⏱ 2021-05-07 19:22:44 

- 📌 lock（）不能被中断，对应的lockInterruptibly（）可以被中断。 
    - ⏱ 2021-05-07 19:24:41 

- 📌 于是他排在队伍末尾，遵循先到者优先服务的规则，这叫公平；如果他去了不排队，直接冲到窗口买票，这叫作不公平 
    - ⏱ 2021-05-07 19:25:50 

- 📌 为了实现一把具有阻塞或唤醒功能的锁，需要几个核心要素：① 需要一个state变量，标记该锁的状态。state变量至少有两个值：0、1。对state变量的操作，要确保线程安全，也就是会用到CAS。② 需要记录当前是哪个线程持有锁。③ 需要底层支持对一个线程进行阻塞或唤醒操作。 
    - ⏱ 2021-05-07 19:26:43 

- 📌 ④ 需要有一个队列维护所有阻塞的线程。这个队列也必须是线程安全的无锁队列，也需要用到CAS。 
    - ⏱ 2021-05-07 19:26:56 

- 📌 state 
    - ⏱ 2021-05-07 19:34:09 

- 📌 在Unsafe类中，提供了阻塞或唤醒线程的一对操作原语，也就是park/unpark。 
    - ⏱ 2021-05-07 20:56:06 

- 📌 尤其是unpark（Thread t），它实现了一个线程对另外一个线程的“精准唤醒”。前面讲到的wait（）/notify（），notify也只是唤醒某一个线程，但无法指定具体唤醒哪个线程。 
    - ⏱ 2021-05-07 21:16:43 

- 📌 在AQS中利用双向链表和CAS实现了一个阻塞队列 
    - ⏱ 2021-05-07 20:54:27 

- 📌 head指向双向链表头部，tail指向双向链表尾部。入队就是把新的Node加到tail后面，然后对tail进行CAS操作；出队就是对head进行CAS操作，把head向后移一个位置。 
    - ⏱ 2021-05-07 21:18:22 

- 📌 唯一的区别是第二段代码多了一个if（！hasQueuedPredecessors（））。什么意思呢？就是只有当c==0（没有线程持有锁），并且排在队列的第1个时（即当队列中没有其他线程的时候），才去抢锁，否则继续排队，这才叫“公平” 
    - ⏱ 2021-05-07 21:19:59 

- 📌 unlock不区分公平还是非公平。 
    - ⏱ 2021-05-07 21:23:14 

- 📌 release（）里面做了两件事：tryRelease（..）函数释放锁；unparkSuccessor（..）函数唤醒队列中的后继者。 
    - ⏱ 2021-05-07 21:23:52 

- 📌 上面的lock 不能被中断，这里的lockInterruptibly（）可以被中断，下面看一下两者在实现上有什么差别。 
    - ⏱ 2021-05-07 21:51:24 
# 读书笔记

# 本书评论
