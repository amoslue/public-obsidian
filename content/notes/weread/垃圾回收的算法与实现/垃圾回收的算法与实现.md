---
doc_type: weread-highlights-reviews
bookId: "26211915"
author: 中村成洋 相川光
cover: https://cdn.weread.qq.com/weread/cover/47/YueWen_26211915/t7_YueWen_26211915.jpg
reviewCount: 0
noteCount: 10
isbn: 9787115427472
category: 计算机-编程设计
lastReadDate: 2021-06-30
---
# 元数据
> [!abstract] 垃圾回收的算法与实现
> - ![ 垃圾回收的算法与实现|200](https://cdn.weread.qq.com/weread/cover/47/YueWen_26211915/t7_YueWen_26211915.jpg)
> - 书名： 垃圾回收的算法与实现
> - 作者： 中村成洋 相川光
> - 简介： 本书分为“算法篇”和“实现篇”两大部分。算法篇介绍了标记-清除算法、引用计数法、复制算法、标记-压缩算法、保守式GC、分代垃圾回收、增量式垃圾回收、RC Immix算法等几种重要的算法；实现篇介绍了垃圾回收在Python、DalvikVM、Rubinius、V8等几种语言处理程序中的具体实现。本书适合各领域程序员阅读。
> - 出版时间 2016-08-08 00:00:00
> - ISBN： 9787115427472
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社

# 高亮划线

## 算法篇


- 📌 然而在GC的世界中，对象表示的是“通过应用程序利用的数据的集合”。 
    - ⏱ 2021-03-11 22:43:33 

- 📌 与全局变量空间相同，我们也可以通过mutator直接引用调用栈（call stack）和寄存器。也就是说，调用栈、寄存器以及全局变量空间都是根 
    - ⏱ 2021-06-07 18:31:46 

- 📌 GC在一般情况下无法严谨地判断寄存器和调用栈中的值是指针还是非指针 
    - ⏱ 2021-06-07 18:32:11 

- 📌 在大小为HEAP_SIZE的堆进行内存管理，要花费的时长为（A+B+C）。因此，这种情况下GC的吞吐量为HEAP_SIZE/（A+B+C）。 
    - ⏱ 2021-06-07 18:34:09 
## 2 GC标记-清除算法


- 📌 标记阶段是把所有活动对象都做上标记的阶段。清除阶段是把那些没有标记的对象，也就是非活动对象回收的阶段 
    - ⏱ 2021-06-07 20:08:48 

- 📌 为此，我们首先要标记通过根直接引用的对象。这里的“对象”就是我们在1.8节中讲到的“确实活动着的对象”。首先我们标记这样的对象，然后递归地标记通过指针数组能访问到的对象。这样就能把所有活动对象都标记上了。 
    - ⏱ 2021-06-07 20:09:29 

- 📌 设置了标志位，就说明这个对象是活动对象。活动对象必然是不能回收的。在第5行我们取消标志位，准备下一次的GC。我们必须把非活动对象回收再利用。回收对象就是把对象作为分块，连接到被称为“空闲链表”的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到 
    - ⏱ 2021-06-07 20:14:36 

- 📌 搜索空闲链表并寻找大小合适的分块，这项操作就叫作分配 
    - ⏱ 2021-06-07 20:18:11 

- 📌 写时复制技术只是装作已经复制了内存空间，实际上是将内存空间共享了。 
    - ⏱ 2021-06-30 20:39:04 

- 📌 然而，当我们对共享内存空间进行写入时，不能直接重写共享内存。因为从其他程序访问时，会发生数据不一致的情况。在重写时，要复制自己私有空间的数据，对这个私有空间进行重写。复制后只访问这个私有空间，不访问共享内存。像这样，因为这门技术是“在写入时进行复制”的，所以才被称为写时复制技术。 
    - ⏱ 2021-06-30 20:39:06 
# 读书笔记

# 本书评论
