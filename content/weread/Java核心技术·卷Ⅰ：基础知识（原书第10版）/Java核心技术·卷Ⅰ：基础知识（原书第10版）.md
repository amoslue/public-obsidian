---
doc_type: weread-highlights-reviews
bookId: "840978"
author: 凯S.霍斯特曼
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/978/840978/t7_840978.jpg
reviewCount: 4
noteCount: 60
isbn: 9787111547426
category: 计算机-计算机综合
lastReadDate: 2022-03-21
---
# 元数据
> [!abstract] Java核心技术·卷Ⅰ：基础知识（原书第10版）
> - ![ Java核心技术·卷Ⅰ：基础知识（原书第10版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/978/840978/t7_840978.jpg)
> - 书名： Java核心技术·卷Ⅰ：基础知识（原书第10版）
> - 作者： 凯S.霍斯特曼
> - 简介： 本书是《Java核心技术》第10版的卷Ⅰ。自《Java核心技术》出版以来，每个新版本都尽可能快地跟上Java开发工具箱发展的步伐，而且每一版都重新改写了部分内容，以便适应Java的最新特性。在这一版中，已经反映了Java标准版（Java SE 8）的特性。与前几版一样，本版仍然将读者群定位在那些打算将Java应用到实际工程项目中的程序设计人员。本书假设读者是一名具有程序设计语言（除Java之外）坚实背景知识的程序设计人员，并且不希望书中充斥着玩具式的示例（诸如，烤面包机、动物园的动物或神经质的跳动文本）。这些内容绝对不会在本书中出现。本书的目标是让读者充分理解书中介绍的Java语言及Java类库的相关特性，而不会产生任何误解。在本书中，我们选用大量的示例代码演示所讨论的每一个语言特性和类库特性。我们有意使用简单的示例程序以突出重点，然而，其中的大部分既不是赝品也没有偷工减料。它们将成为读者自己编写代码的良好开端。
> - 出版时间 2016-09-01 00:00:00
> - ISBN： 9787111547426
> - 分类： 计算机-计算机综合
> - 出版社： 机械工业出版社

# 高亮划线

## 3.1 一个简单的Java应用程序


- 📌 Java区分大小写 
    - ⏱ 2021-02-17 23:59:30 

- 📌 Java中定义类名的规则很宽松。名字必须以字母开头，后面可以跟字母和数字的任意组合。长度基本上没有限制。但是不能使用Java保留字（例如，public或class）作为类名（ 
    - ⏱ 2021-02-18 00:04:56 

- 📌 源代码的文件名必须与公共类的名字相同，并用．java作为扩展名 
    - ⏱ 2021-02-18 00:05:39 

- 📌 Java中任何方法的代码都用“{”开始，用“}”结束。 
    - ⏱ 2021-02-18 00:12:14 
## 4.1 面向对象程序设计概述


- 📌 局部变量不会自动地初始化为null，而必须通过调用new或将它们设置为null进行初始化。 
    - ⏱ 2021-02-19 23:31:30 

- 📌 可以将Java的对象变量看作C++的对象指针 
    - ⏱ 2021-02-19 23:29:56 

- 📌 所有的Java对象都存储在堆中 
    - ⏱ 2021-02-19 23:31:40 

- 📌 一种是使用通配符调用Java编译器： 
    - ⏱ 2021-02-19 23:46:26 

- 📌 构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的 
    - ⏱ 2021-02-19 23:51:33 

- 📌 ● 构造器与类同名● 每个类可以有一个以上的构造器● 构造器可以有0个、1个或多个参数● 构造器没有返回值● 构造器总是伴随着new操作一起调用 
    - ⏱ 2021-02-19 23:51:54 

- 📌 要记住所有的Java对象都是在堆中构造的，构造器总是伴随着new操作符一起使用。 
    - ⏱ 2021-02-19 23:52:47 

- 📌 在所有的方法中不要命名与实例域同名的变量。 
    - ⏱ 2021-02-19 23:54:57 

- 📌 关键字this表示隐式参数 
    - ⏱ 2021-02-19 23:58:19 

- 📌 所有的方法都必须在类的内部定义，但并不表示它们是内联方法 
    - ⏱ 2021-02-19 23:57:46 

- 📌 由于它们只返回实例域值，因此又称为域访问器 
    - ⏱ 2021-02-20 10:34:41 

- 📌 所以应该将所有的数据域都设置为私有的。 
    - ⏱ 2021-02-20 14:48:27 

- 📌 它不会被外部的其他类操作调用，可以将其删去。如果方法是公有的，就不能将其删去，因为其他的代码很可能依赖它 
    - ⏱ 2021-02-20 14:48:28 

- 📌 如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。于是，实例域中的数值型数据设置为0、布尔型数据设置为false、所有对象变量将设置为null。如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法 
    - ⏱ 2021-02-22 15:45:01 

- 📌 当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。 
    - ⏱ 2021-02-22 15:45:25 

- 📌 如果构造器的第一个语句形如this(...)，这个构造器将调用同一个类的另一个构造器。 
    - ⏱ 2021-02-22 15:47:25 

- 📌 首先运行初始化块，然后才运行构造器的主体部分 
    - ⏱ 2021-02-22 15:39:18 

- 📌 从Java SE 7以后，java程序首先会检查是否有一个main方法。 
    - ⏱ 2021-02-22 15:43:21 

- 📌 可以为任何一个类添加finalize方法。finalize方法将在垃圾回收器清除对象之前调用。 
    - ⏱ 2021-02-22 15:55:42 

- 📌 一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）。 
    - ⏱ 2021-02-22 15:58:08 

- 📌 编译器对文件（带有文件分隔符和扩展名．java的文件）进行操作。而Java解释器加载类（带有．分隔符） 
    - ⏱ 2021-02-22 16:06:52 
## 5.1 类、超类和子类


- 📌 能够分析类能力的程序称为反射 
    - ⏱ 2021-02-26 15:48:22 

- 📌 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行 
    - ⏱ 2021-02-26 15:51:19 

- 📌 可以调用静态方法forName获得类名对应的Class对象。 
    - ⏱ 2022-03-20 08:00:20 

- 📌 className是类名或接口名时才能够执行 
    - ⏱ 2021-02-26 15:52:42 

- 📌 否则，forName方法将抛出一个checkedexception（已检查异常） 
    - ⏱ 2022-03-20 08:01:58 
 

- 📌 一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。 
    - ⏱ 2022-03-20 08:03:17 

- 📌 newInstance方法调用默认的构造器（没有参数的构造器）初始化新创建的对象。如果这个类没有默认的构造器，就会抛出一个异常 
    - ⏱ 2022-03-20 08:12:21 

- 📌 在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器 
    - ⏱ 2021-02-26 15:55:14 

- 📌 protected方法对于指示那些不提供一般用途而应在子类中重新定义的方法很有用。 
    - ⏱ 2022-03-20 08:23:42 
## 6.1 接口


- 📌 假设stream方法不是一个默认方法。那么Bag类将不能编译，因为它没有实现这个新方法。为接口增加一个非默认方法不能保证“源代码兼容”（source compatible）。 
    - ⏱ 2022-03-20 08:31:50 
 

- 📌 不过，Java设计者更强调一致性。两个接口如何冲突并不重要。如果至少有一个接口提供了一个实现，编译器就会报告错误，而程序员就必须解决这个二义性。 
    - ⏱ 2022-03-20 08:39:56 

- 📌 从超类和接口继承了相同的方法 
    - ⏱ 2022-03-20 08:40:24 
 

- 📌 千万不要让一个默认方法重新定义Object类中的某个方法。例如，不能为toString或equals定义默认方法，尽管对于List之类的接口这可能很有吸引力。由于“类优先”规则，这样的方法绝对无法超越Object.toString或Objects.equals。 
    - ⏱ 2022-03-20 08:41:26 

- 📌 内部类（inner class）是定义在另一个类中的类 
    - ⏱ 2022-03-21 16:50:32 

- 📌 ● 内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。● 内部类可以对同一个包中的其他类隐藏起来。● 当想要定义一个回调函数且不想编写大量代码时，使用匿名（anonymous）内部类比较便捷 
    - ⏱ 2022-03-21 16:50:54 

- 📌 内部类的对象有一个隐式引用，它引用了实例化该内部对象的外围类对象。通过这个指针，可以访问外围类对象的全部状态。 
    - ⏱ 2022-03-21 16:51:59 

- 📌 。内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。 
    - ⏱ 2022-03-21 17:19:05 

- 📌 内部类中声明的所有静态域都必须是final。原因很简单。我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是final，它可能就不是唯一的。 
    - ⏱ 2022-03-21 17:20:23 

- 📌 内部类不能有static方法 
    - ⏱ 2022-03-21 17:20:47 

- 📌 TalkingClock$Time Printer.class 
    - ⏱ 2022-03-21 17:21:30 

- 📌 可以在一个方法中定义局部类 
    - ⏱ 2022-03-21 17:22:27 

- 📌 局部类不能用public或private访问说明符进行声明。它的作用域被限定在声明这个局部类的块中 
    - ⏱ 2022-03-21 17:22:33 

- 📌 局部类有一个优势，即对外部世界可以完全地隐藏起来 
    - ⏱ 2022-03-21 17:22:42 

- 📌 假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类（anonymousinner class）。 
    - ⏱ 2022-03-21 17:25:44 

- 📌 由于构造器的名字必须与类名相同，而匿名类没有类名，所以，匿名类不能有构造器 
    - ⏱ 2022-03-21 17:28:15 

- 📌 如果构造参数的闭小括号后面跟一个开大括号，正在定义的就是匿名内部类。 
    - ⏱ 2022-03-21 17:28:58 

- 📌 外层括号建立了ArrayList的一个匿名子类。内层括号则是一个对象构造块 
    - ⏱ 2022-03-21 17:29:52 
## 14.1 什么是线程


- 📌 如果将队列当作线程管理工具来使用，将要用到put和take方法 
    - ⏱ 2022-03-21 17:43:15 

- 📌 一定要使用offer、poll和peek方法作为替代 
    - ⏱ 2022-03-21 17:43:38 

- 📌 poll和peek方法返回空来指示失败。因此，向这些队列中插入null值是非法的。 
    - ⏱ 2022-03-21 17:44:03 

- 📌 LinkedBlockingQueue的容量是没有上边界的 
    - ⏱ 2022-03-21 17:55:24 

- 📌 ArrayBlockingQueue在构造时需要指定容量，并且有一个可选的参数来指定是否需要公平性。若设置了公平参数，则那么等待了最长时间的线程会优先得到处理。通常，公平性会降低性能，只有在确实非常需要时才使用它。 
    - ⏱ 2022-03-21 17:55:36 
# 读书笔记

## 4.1 面向对象程序设计概述

### 划线评论
- 📌 final实例域 
    - 💭 
一、final修饰引用：
1.若引用为基本数据类型，则被修饰的该引用的值变为常量(有点像c中的常量指针？)
2.若引用为对象或数组，则该对象或数组本身可以修改，但是该数组或对象的地址引用不能修改(类似指针常量？)
3.若引用为类的成员变量，需要当场赋值

二、final修饰方法:
被修饰的方法变为最终方法，无法被子类重写，但可以被继承。

三、final修饰类
被修饰后该类无法被继承，“断子绝孙类”
    - ⏱ 2021-02-21 12:47:46
   
## 5.1 类、超类和子类

### 划线评论
- 📌 如果T是任意的Java类型（或void关键字）, T.class将代表匹配的类对象 
    - 💭 getClass()用于Object
.class用于类
    - ⏱ 2022-03-20 08:11:36
   
## 6.1 接口

### 划线评论
- 📌 在这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略。 
    - 💭 父类优先，接口的同名默认方法被忽略
    - ⏱ 2022-03-20 08:41:02

### 划线评论
- 📌 类会继承Person和Named接口提供的两个不一致的getName方法。并不是从中选择一个，Java编译器会报告一个错误，让程序员来解决这个二义性 
    - 💭 编译不过！
    - ⏱ 2022-03-20 08:38:52
   
# 本书评论
