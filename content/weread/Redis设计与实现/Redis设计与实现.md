---
doc_type: weread-highlights-reviews
bookId: "622000"
author: 黄健宏
cover: https://cdn.weread.qq.com/weread/cover/54/YueWen_622000/t7_YueWen_622000.jpg
reviewCount: 18
noteCount: 193
isbn: 9787111464747
category: 计算机-编程设计
lastReadDate: 2022-03-28
---
# 元数据
> [!abstract] Redis设计与实现
> - ![ Redis设计与实现|200](https://cdn.weread.qq.com/weread/cover/54/YueWen_622000/t7_YueWen_622000.jpg)
> - 书名： Redis设计与实现
> - 作者： 黄健宏
> - 简介： 《Redis设计与实现》对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，这些知识可以帮助读者更好、更高效地使用Redis。本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制（replication）、集群（cluster）三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。
> - 出版时间 2015-01-01 00:00:00
> - ISBN： 9787111464747
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社

# 高亮划线

## 2.2 SDS与C字符串的区别


- 📌 常数复杂度获取字符串长度 
    - ⏱ 2021-08-12 21:21:54 

- 📌 因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1 
    - ⏱ 2021-08-12 21:20:43 

- 📌 杜绝缓冲区溢出 
    - ⏱ 2021-08-12 21:22:00 

- 📌 那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间中，导致s2保存的内容被意外地修改 
    - ⏱ 2021-08-12 21:23:46 

- 📌 当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。 
    - ⏱ 2021-08-12 21:23:56 

- 📌 sdscat不仅对这个SDS进行了拼接操作，它还为SDS分配了13字节的未使用空间，并且拼接之后的字符串也正好是13字节长，这种现象既不是bug也不是巧合，它和SDS的空间分配策略有关 
    - ⏱ 2021-08-12 21:24:53 

- 📌 空间预分配用于优化SDS的字符串增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须要的空间，还会为SDS分配额外的未使用空间 
    - ⏱ 2021-08-12 21:30:10 

- 📌 SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间 
    - ⏱ 2021-08-12 21:32:31 

- 📌 额外的一字节用于保存空字符 
    - ⏱ 2021-08-12 21:32:43 

- 📌 SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间 
    - ⏱ 2021-08-12 21:33:03 

- 📌 因为SDS使用len属性的值而不是空字符来判断字符串是否结束 
    - ⏱ 2021-08-12 21:39:37 
## 2.3 SDS API


- 📌 DS的主要操作API 
    - ⏱ 2021-08-12 21:42:07 
## 2.4 重点回顾


- 📌 1）常数复杂度获取字符串长度。2）杜绝缓冲区溢出。3）减少修改字符串长度时所需的内存重分配次数。4）二进制安全。5）兼容部分C字符串函数。 
    - ⏱ 2021-08-12 21:42:15 
## 9.1 服务器中的数据库


- 📌 Redis服务器将所有数据库都保存在服务器状态redis.h/redisServer结构的db数组中，db数组的每个项都是一个redis.h/redisDb结构，每个redisDb结构代表一个数据库： 
    - ⏱ 2021-12-14 09:12:18 

- 📌 所以Redis服务器默认会创建16个数据库 
    - ⏱ 2021-12-14 09:12:49 
## 9.2 切换数据库


- 📌 SELECT命令来切换目标数据库 
    - ⏱ 2021-12-14 09:14:09 

- 📌 redisClient.db指针指向redisServer.db数组的其中一个元素，而被指向的元素就是客户端的目标数据库 
    - ⏱ 2021-12-14 09:14:55 

- 📌 通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的实现原理。 
    - ⏱ 2021-12-14 09:15:31 

- 📌 最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令 
    - ⏱ 2021-12-14 09:16:08 
## 9.3 数据库键空间


- 📌 edisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间 
    - ⏱ 2021-12-14 09:19:29 

- 📌 删除数据库中的一个键，实际上就是在键空间里面删除键所对应的键值对对象。 
    - ⏱ 2021-12-14 09:22:25 

- 📌 用于清空整个数据库的FLUSHDB命令，就是通过删除键空间中的所有键值对来实现的。 
    - ⏱ 2021-12-20 15:06:42 
## 9.4 设置键的生存时间或过期时间


- 📌 通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键： 
    - ⏱ 2021-12-20 15:08:54 

- 📌 EXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl秒。❑PEXPIRE＜key＞＜ttl＞命令用于将键key的生存时间设置为ttl毫秒。❑EXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。❑PEXPIREAT＜key＞＜timestamp＞命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。 
    - ⏱ 2021-12-20 15:13:09 

- 📌 PEXPIREAT命令来实现的：无论客户端执行的是以上四个命令中的哪一个，经过转换之后，最终的执行效果都和执行PEXPIREAT命令一 
    - ⏱ 2021-12-20 15:13:33 

- 📌 redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称这个字典为过期字典： 
    - ⏱ 2021-12-20 15:16:29 
 

- 📌 PERSIST命令可以移除一个键的过期时间 
    - ⏱ 2021-12-20 15:27:43 

- 📌 PERSIST命令就是PEXPIREAT命令的反操作：PERSIST命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。 
    - ⏱ 2021-12-20 15:28:16 

- 📌 TTL和PTTL两个命令都是通过计算键的过期时间和当前时间之间的差来实现的 
    - ⏱ 2021-12-20 15:30:08 

- 📌 is_expired（alphabet）将返回False，因为当前时间小于alphabet键的过期时间。 
    - ⏱ 2021-12-20 15:31:02 

- 📌 执行TTL命令，并且命令返回的值大于等于0，那么说明该键未过期 
    - ⏱ 2021-12-20 15:31:32 

- 📌 在实际中，Redis检查键是否过期的方法和is_expired函数所描述的方法一致，因为直接访问字典比执行一个命令稍微快一些。 
    - ⏱ 2021-12-20 15:31:43 
## 9.5 过期键删除策略


- 📌 ❑定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。❑惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。❑定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。 
    - ⏱ 2021-12-20 15:37:53 
 

- 📌 它对CPU时间是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。 
    - ⏱ 2021-12-20 15:42:09 
 

- 📌 程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。 
    - ⏱ 2021-12-20 15:59:56 

- 📌 它对内存是最不友好的 
    - ⏱ 2021-12-20 16:00:05 

- 📌 我们甚至可以将这种情况看作是一种内存泄漏——无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。 
    - ⏱ 2021-12-20 16:00:18 

- 📌 定期删除策略是前两种策略的一种整合和折中： 
    - ⏱ 2021-12-20 16:01:13 
## 9.6 Redis的过期键删除策略


- 📌 Redis服务器实际使用的是惰性删除和定期删除两种策略 
    - ⏱ 2021-12-20 16:01:49 
## 9.7 AOF、RDB和复制功能对过期键的处理


- 📌 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中 
    - ⏱ 2021-12-23 16:01:41 

- 📌 ❑如果服务器以主服务器模式运行，那么程序只会将k1和k3载入到数据库，k2会被忽略。❑如果服务器以从服务器模式运行，那么k1、k2和k3都会被载入到数据库。 
    - ⏱ 2021-12-23 16:02:08 

- 📌 当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除 
    - ⏱ 2021-12-23 16:02:43 

- 📌 ❑主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。❑从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。❑从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。 
    - ⏱ 2021-12-23 16:08:11 

- 📌 通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器数据的一致性，也正是因为这个原因，当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在 
    - ⏱ 2022-01-01 19:04:23 

- 📌 假设在此之后，有客户端向主服务器发送命令GET message，那么主服务器将发现键message已经过期：主服务器会删除message键，向客户端返回空回复，并向从服务器发送DEL message命令 
    - ⏱ 2022-01-01 19:04:48 
## 9.9 重点回顾


- 📌 ❑Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存 
    - ⏱ 2022-01-01 19:08:13 

- 📌 ，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。 
    - ⏱ 2022-01-01 19:08:10 

- 📌 Redis使用惰性删除和定期删除两种策略来删除过期的键：惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔一段时间主动查找并删除过期键。 
    - ⏱ 2022-01-01 19:08:53 

- 📌 执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。 
    - ⏱ 2022-01-01 19:09:09 

- 📌 当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。 
    - ⏱ 2022-01-01 19:10:05 
## 第10章 RDB持久化


- 📌 服务器中的非空数据库以及它们的键值对统称为数据库状态 
    - ⏱ 2022-01-01 19:20:16 
 

- 📌 RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态 
    - ⏱ 2022-01-01 19:27:34 

- 📌 RDB文件是保存在硬盘里面的 
    - ⏱ 2022-01-01 19:28:46 
## 10.1 RDB文件的创建与载入


- 📌 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE 
    - ⏱ 2022-01-01 20:36:12 

- 📌 SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求 
    - ⏱ 2022-01-01 20:36:17 

- 📌 ，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求： 
    - ⏱ 2022-01-03 13:12:57 

- 📌 只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。 
    - ⏱ 2022-01-03 13:14:08 

- 📌 ❑如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。❑只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。 
    - ⏱ 2022-01-03 13:14:31 

- 📌 BGSAVE命令的保存工作是由子进程执行的 
    - ⏱ 2022-01-03 15:32:48 

- 📌 首先，在BGSAVE命令执行期间，客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令和BGSAVE命令同时执行是为了避免父进程（服务器进程）和子进程同时执行两个rdbSave调用，防止产生竞争条件。 
    - ⏱ 2022-01-03 15:32:40 

- 📌 其次，在BGSAVE命令执行期间，客户端发送的BGSAVE命令会被服务器拒绝，因为同时执行两个BGSAVE命令也会产生竞争条件 
    - ⏱ 2022-03-28 13:54:37 

- 📌 服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止 
    - ⏱ 2022-01-03 15:33:52 
## 10.2 自动间隔性保存


- 📌 SAVE命令由服务器进程执行保存工作，BGSAVE命令则由子进程执行保存工作，所以SAVE命令会阻塞服务器，而BGSAVE命令则不会 
    - ⏱ 2022-01-03 15:34:07 

- 📌 根据save选项所设置的保存条件，设置服务器状态redisServer结构的saveparams属性 
    - ⏱ 2022-01-03 15:35:45 

- 📌 saveparams属性是一个数组，数组中的每个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件： 
    - ⏱ 2022-01-03 15:35:55 

- 📌 dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态（服务器中的所有数据库）进行了多少次修改（包括写入、删除、更新等操作）。 
    - ⏱ 2022-01-03 15:36:17 

- 📌 lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。 
    - ⏱ 2022-01-03 15:36:23 
## 10.3 RDB文件结构


- 📌 RDB文件所包含的各个部分 
    - ⏱ 2022-01-03 15:40:15 

- 📌 RDB文件的最开头是REDIS部分，这个部分的长度为5字节，保存着“REDIS”五个字符。通过这五个字符，程序可以在载入文件时，快速检查所载入的文件是否RDB文件。 
    - ⏱ 2022-01-03 15:40:43 

- 📌 RDB文件保存的是二进制数据 
    - ⏱ 2022-01-03 15:41:15 

- 📌 db_version长度为4字节，它的值是一个字符串表示的整数，这个整数记录了RDB文件的版本号，比如"0006"就代表RDB文件的版本为第六版 
    - ⏱ 2022-01-03 15:41:43 

- 📌 databases部分包含着零个或任意多个数据库，以及各个数据库中的键值对数据 
    - ⏱ 2022-01-03 15:41:49 

- 📌 EOF常量的长度为1字节，这个常量标志着RDB文件正文内容的结束，当读入程序遇到这个值的时候，它知道所有数据库的所有键值对都已经载入完毕了。 
    - ⏱ 2022-01-03 15:42:04 

- 📌 check_sum是一个8字节长的无符号整数，保存着一个校验和，这个校验和是程序通过对REDIS、db_version、databases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时，会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比，以此来检查RDB文件是否有出错或者损坏的情况出现。 
    - ⏱ 2022-01-03 15:46:01 

- 📌 非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三个部分 
    - ⏱ 2022-01-03 15:49:22 

- 📌 SELECTDB常量的长度为1字节，当读入程序遇到这个值的时候，它知道接下来要读入的将是一个数据库号码。 
    - ⏱ 2022-01-03 15:49:16 

- 📌 读入db_number部分之后，服务器会调用SELECT命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。 
    - ⏱ 2022-01-03 15:50:17 

- 📌 key_value_pairs部分保存了数据库中的所有键值对数据，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起 
    - ⏱ 2022-01-03 15:50:42 

- 📌 不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成 
    - ⏱ 2022-01-03 15:51:05 

- 📌 TYPE记录了value的类型 
    - ⏱ 2022-01-03 15:51:51 

- 📌 ❑EXPIRETIME_MS常量的长度为1字节，它告知读入程序，接下来要读入的将是一个以毫秒为单位的过期时间。❑ms是一个8字节长的带符号整数，记录着一个以毫秒为单位的UNIX时间戳，这个时间戳就是键值对的过期时间。 
    - ⏱ 2022-01-03 15:58:43 
## 10.5 重点回顾


- 📌 ❑RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据。❑SAVE命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。❑BGSAVE令由子进程执行保存操作，所以该命令不会阻塞服务器。❑服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足时，服务器会自动执行BGSAVE命令。❑RDB文件是一个经过压缩的二进制文件，由多个部分组成。❑对于不同类型的键值对，RDB文件会使用不同的方式来保存它们。 
    - ⏱ 2022-01-03 16:06:12 
## 第11章 AOF持久化

 

- 📌 RDB持久化保存数据库状态的方法是将msg、fruits、numbers三个键的键值对保存到RDB文件中，而AOF持久化保存数据库状态的方法则是将服务器执行的SET、SADD、RPUSH三个命令保存到AOF文件中 
    - ⏱ 2022-01-06 14:53:31 
## 11.1 AOF持久化的实现


- 📌 命令追加（append）、文件写入、文件同步（sync）三个步骤 
    - ⏱ 2022-01-06 14:55:12 

- 📌 服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾 
    - ⏱ 2022-01-06 15:24:35 

- 📌 它都会调用flushAppendOnlyFile函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面 
    - ⏱ 2022-01-06 15:28:37 

- 📌 ，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面 
    - ⏱ 2022-01-06 15:29:47 

- 📌 系统提供了fsync和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性 
    - ⏱ 2022-01-06 15:30:09 
## 11.2 AOF文件的载入与数据还原


- 📌 因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。 
    - ⏱ 2022-01-08 20:03:53 
## 11.3 AOF重写


- 📌 为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能 
    - ⏱ 2022-01-08 20:05:04 

- 📌 通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。 
    - ⏱ 2022-01-08 20:05:18 

- 📌 AOF文件重写并不需要对现有的AOF文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的 
    - ⏱ 2022-01-08 20:08:01 
 

- 📌 因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞 
    - ⏱ 2022-01-08 20:12:00 

- 📌 Redis不希望AOF重写造成服务器无法处理请求，所以Redis决定将AOF重写程序放到子进程里执行 
    - ⏱ 2022-01-08 20:12:28 
 
 

- 📌 为了解决这种数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区 
    - ⏱ 2022-01-08 20:14:21 

- 📌 在子进程执行AOF重写期间，服务器进程需要执行以下三个工作：1）执行客户端发来的命令。2）将执行后的写命令追加到AOF缓冲区。3）将执行后的写命令追加到AOF重写缓冲区。 
    - ⏱ 2022-01-08 20:14:40 

- 📌 ❑AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF文件的处理工作会如常进行。❑从创建子进程开始，服务器执行的所有写命令都会被记录到AOF重写缓冲区里面。 
    - ⏱ 2022-01-08 20:14:51 

- 📌 1）将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件所保存的数据库状态将和服务器当前的数据库状态一致。2）对新的AOF文件进行改名，原子地（atomic）覆盖现有的AOF文件，完成新旧两个AOF文件的替换。 
    - ⏱ 2022-01-08 20:15:17 

- 📌 在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。 
    - ⏱ 2022-01-08 20:15:54 

- 📌 BGREWRITEAOF 
    - ⏱ 2022-01-08 20:16:13 
## 11.4 重点回顾


- 📌 OF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。 
    - ⏱ 2022-03-28 14:05:35 
## 15.1 旧版复制功能的实现


- 📌 ❑同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。 
    - ⏱ 2022-01-26 14:07:05 

- 📌 ❑命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。 
    - ⏱ 2022-01-26 14:07:47 
 

- 📌 主从服务器两者的数据库将达到一致状态，但这种一致并不是一成不变的，每当主服务器执行客户端发送的写命令时，主服务器的数据库就有可能会被修改，并导致主从服务器状态不再一致。 
    - ⏱ 2022-01-26 14:12:38 

- 📌 主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。 
    - ⏱ 2022-01-26 14:14:01 
## 15.2 旧版复制功能的缺陷


- 📌 每次执行SYNC命令，主从服务器需要执行以下动作：1）主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。2）主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量），并对主服务器响应命令请求的时间产生影响。3）接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻塞而没办法处理命令请求。因为SYNC命令是一个如此耗费资源的操作，所以Redis有必要保证在真正有需要时才执行SYNC命令。 
    - ⏱ 2022-01-26 14:18:58 
## 15.3 新版复制功能的实现


- 📌 PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partialresynchronization）两种模式： 
    - ⏱ 2022-01-26 14:51:33 

- 📌 完整重同步的执行步骤和SYNC命令的执行步骤基本一样 
    - ⏱ 2022-01-26 14:52:10 

- 📌 主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。 
    - ⏱ 2022-01-26 14:52:28 
## 第16章 Sentinel


- 📌 ❑首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。❑之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。❑另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。 
    - ⏱ 2022-02-14 15:38:39 
## 16.1 启动并初始化Sentinel


- 📌 普通服务器在初始化时会通过载入RDB文件或者AOF文件来还原数据库状态，但是因为Sentinel并不使用数据库，所以初始化Sentinel时就不会载入RDB文件或者AOF文件。 
    - ⏱ 2022-02-14 16:01:20 

- 📌 Sentinel则使用sentinel.c/REDIS_SENTINEL_PORT常量的值作为服务器端口 
    - ⏱ 2022-02-14 16:02:25 

- 📌 PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE和PUNSUBSCRIBE 
    - ⏱ 2022-02-14 16:02:52 

- 📌 服务器会初始化一个sentinel.c/sentinelState结构（后面简称“Sentinel状态”），这个结构保存了服务器中所有和Sentinel功能有关的状态（服务器的一般状态仍然由redis.h/redisServer结构保存）： 
    - ⏱ 2022-02-14 16:03:55 

- 📌 masters字典记录了所有被Sentinel监视的主服务器的相关信 
    - ⏱ 2022-02-14 16:04:10 

- 📌 ❑字典的键是被监视主服务器的名字。❑而字典的值则是被监视主服务器对应的sentinel.c/sentinelRedisInstance结构 
    - ⏱ 2022-02-14 16:04:21 
 

- 📌 对于每个被Sentinel监视的主服务器来说，Sentinel会创建两个连向主服务器的异步网络连接：❑一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。❑另一个是订阅连接，这个连接专门用于订阅主服务器的__sentinel__:hello频道。 
    - ⏱ 2022-02-14 16:07:04 
## 16.2 获取主服务器信息


- 📌 Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。 
    - ⏱ 2022-02-14 16:09:16 
 

- 📌 字典的键是由Sentinel自动设置的从服务器名字 
    - ⏱ 2022-02-14 16:11:19 

- 📌 至于字典的值则是从服务器对应的实例结构 
    - ⏱ 2022-02-14 16:11:22 

- 📌 主服务器实例结构的name属性的值是用户使用Sentinel配置文件设置的，而从服务器实例结构的name属性的值则是Sentinel根据从服务器的IP地址和端口号自动设置的。 
    - ⏱ 2022-02-14 16:12:25 
## 16.3 获取从服务器信息


- 📌 Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。 
    - ⏱ 2022-02-14 16:13:05 
## 16.5 接收来自主服务器和从服务器的频道信息


- 📌 Sentinel对__sentinel__:hello频道的订阅会一直持续到Sentinel与服务器的连接断开为止。 
    - ⏱ 2022-02-16 12:40:28 

- 📌 Sentinel既通过命令连接向服务器的__sentinel__:hello频道发送信息，又通过订阅连接从服务器的__sentinel__:hello频道接收信息，如图16-13所示。 
    - ⏱ 2022-02-16 12:40:43 

- 📌 对于监视同一个服务器的多个Sentinel来说，一个Sentinel发送的信息会被其他Sentinel接收到，这些信息会被用于更新其他Sentinel对发送信息Sentinel的认知，也会被用于更新其他Sentinel对被监视服务器的认知。 
    - ⏱ 2022-02-16 12:42:14 

- 📌 ❑如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID相同，那么说明这条信息是Sentinel自己发送的，Sentinel将丢弃这条信息，不做进一步处理。❑相反地，如果信息中记录的Sentinel运行ID和接收信息的Sentinel的运行ID不相同，那么说明这条信息是监视同一个服务器的其他Sentinel发来的，接收信息的Sentinel将根据信息中的各个参数，对相应主服务器的实例结构进行更新。 
    - ⏱ 2022-02-16 12:42:58 

- 📌 Sentinel为主服务器创建的实例结构中的sentinels字典保存了除Sentinel本身之外，所有同样监视这个主服务器的其他Sentinel的资料 
    - ⏱ 2022-02-16 14:27:14 

- 📌 监视同一个主服务器的多个Sentinel可以自动发现对方。 
    - ⏱ 2022-02-16 14:47:36 

- 📌 会创建一个连向新Sentinel的命令连接 
    - ⏱ 2022-02-16 14:50:17 

- 📌 Sentinel之间不会创建订阅连接 
    - ⏱ 2022-02-16 14:51:37 
## 16.6 检测主观下线状态


- 📌 Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括主服务器、从服务器、其他Sentinel在内）发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线 
    - ⏱ 2022-02-16 14:51:57 
## 16.8 选举领头Sentinel


- 📌 当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作 
    - ⏱ 2022-02-16 16:27:30 

- 📌 所有在线的Sentinel都有被选为领头Sentinel的资格 
    - ⏱ 2022-02-16 16:27:57 

- 📌 不论选举是否成功，所有Sentinel的配置纪元（configuration epoch）的值都会自增一次 
    - ⏱ 2022-02-16 16:28:09 

- 📌 源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel 
    - ⏱ 2022-02-16 16:28:59 

- 📌 三个Sentinel将再次向其他Sentinel发送SENTINELis-master-down-by-addr命令 
    - ⏱ 2022-02-17 21:11:54 
 
## 16.9 故障转移


- 📌 在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：1）在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。2）让已下线主服务器属下的所有从服务器改为复制新的主服务器。3）将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。 
    - ⏱ 2022-02-17 21:14:25 
 
## 16.10 重点回顾


- 📌 Sentinel只是一个运行在特殊模式下的Redis服务器 
    - ⏱ 2022-02-17 22:42:12 

- 📌 Sentinel以每十秒一次的频率向被监视的主服务器和从服务器发送INFO命令，当主服务器处于下线状态，或者Sentinel正在对主服务器进行故障转移操作时，Sentinel向从服务器发送INFO命令的频率会改为每秒一次。 
    - ⏱ 2022-02-17 22:42:34 

- 📌 对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的__sentinel__:hello频道发送消息来向其他Sentinel宣告自己的存在 
    - ⏱ 2022-02-17 22:43:11 

- 📌 Sentinel与Sentinel之间则只创建命令连接 
    - ⏱ 2022-02-17 22:43:35 

- 📌 当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作 
    - ⏱ 2022-02-17 22:44:49 
## 16.11 参考资料


- 📌 http://v.youku.com/v_show/id_XNjQxOTk5MTk2.html 
    - ⏱ 2022-02-17 22:52:17 
## 第17章 集群


- 📌 集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。 
    - ⏱ 2022-02-17 23:15:57 
## 17.1 节点


- 📌 当握手成功时，node节点就会将ip和port所指定的节点添加到node节点当前所在的集群中 
    - ⏱ 2022-02-17 23:26:20 

- 📌 一个节点就是一个运行在集群模式下的Redis服务器 
    - ⏱ 2022-02-17 23:28:10 

- 📌 节点（运行在集群模式下的Redis服务器）会继续使用所有在单机模式中使用的服务器组件，比如说： 
    - ⏱ 2022-02-17 23:30:17 

- 📌 至于那些只有在集群模式下才会用到的数据，节点将它们保存到了cluster.h/clusterNode结构、cluster.h/clusterLink结构，以及cluster.h/clusterState结构里面 
    - ⏱ 2022-02-17 23:30:11 

- 📌 clusterNode结构保存了一个节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP地址和端口号等等 
    - ⏱ 2022-02-17 23:30:32 

- 📌 clusterNode结构来记录自己的状态 
    - ⏱ 2022-02-17 23:46:42 

- 📌 clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓冲区和输出缓冲区： 
    - ⏱ 2022-02-17 23:37:42 

- 📌 自己的套接字描述符和输入、输出缓冲区，这两个结构的区别在于，redisClient结构中的套接字和缓冲区是用于连接客户端的，而clusterLink结构中的套接字和缓冲区则是用于连接节点的。 
    - ⏱ 2022-02-17 23:39:46 

- 📌 每个节点都保存着一个clusterState结构，这个结构记录了在当前节点的视角下，集群目前所处的状态，例如集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类： 
    - ⏱ 2022-02-17 23:43:34 

- 📌 群当前的配置纪元为0 
    - ⏱ 2022-02-17 23:43:47 

- 📌 集群目前处于下线状态 
    - ⏱ 2022-02-17 23:44:43 

- 📌 结构的nodes字典记录了集群目前包含的三个节点 
    - ⏱ 2022-02-17 23:44:58 

- 📌 clusterNode结构的flags属性都是REDIS_NODE_MASTER，说明三个节点都是主节点。 
    - ⏱ 2022-02-17 23:45:48 
## 17.2 槽指派


- 📌 分片的方式来保存数据库中的键值对 
    - ⏱ 2022-02-18 09:47:27 

- 📌 当数据库中的16384个槽都有节点在处理时，集群处于上线状态（ok）；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。 
    - ⏱ 2022-02-18 09:48:21 

- 📌 CLUSTER ADDSLOTS 
    - ⏱ 2022-02-18 09:49:04 

- 📌 ❑如果slots数组在索引i上的二进制位的值为1，那么表示节点负责处理槽i。❑如果slots数组在索引i上的二进制位的值为0，那么表示节点不负责处理槽i。 
    - ⏱ 2022-02-18 09:51:37 

- 📌 至于numslots属性则记录节点负责处理的槽的数量，也即是slots数组中值为1的二进制位的数量。 
    - ⏱ 2022-02-18 09:51:57 

- 📌 还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽 
    - ⏱ 2022-02-18 09:55:34 

- 📌 节点A会在自己的clusterState.nodes字典中查找节点B对应的clusterNode结构，并对结构中的slots数组进行保存或者更新。 
    - ⏱ 2022-02-18 09:55:51 

- 📌 clusterState结构中的slots数组 
    - ⏱ 2022-02-18 09:58:34 

- 📌 slots数组包含16384个项，每个数组项都是一个指向clusterNode结构的指针：❑如果slots[i]指针指向NULL，那么表示槽i尚未指派给任何节点。❑如果slots[i]指针指向一个clusterNode结构，那么表示槽i已经指派给了clusterNode结构所代表的节点。 
    - ⏱ 2022-02-18 09:58:30 
 

- 📌 clusterNode结构的slots数组来记录单个节点的槽指派信息仍然是有必要的： 
    - ⏱ 2022-02-18 10:16:45 

- 📌 每次要将节点A的槽指派信息传播给其他节点时，程序必须先遍历整个clusterState.slots数组，记录节点A负责处理哪些槽，然后才能发送节点A的槽指派信息，这比直接发送clusterNode.slots数组要麻烦和低效得多。 
    - ⏱ 2022-02-18 10:17:19 

- 📌 clusterState.slots数组记录了集群中所有槽的指派信息，而clusterNode.slots数组只记录了clusterNode结构所代表的节点的槽指派信息，这是两个slots数组的关键区别所在。 
    - ⏱ 2022-02-18 10:17:34 

- 📌 最后，在CLUSTER ADDSLOTS命令执行完毕之后，节点会通过发送消息告知集群中的其他节点，自己目前正在负责处理哪些槽。 
    - ⏱ 2022-02-18 10:21:59 
## 17.3 在集群中执行命令


- 📌 在对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态，这时客户端就可以向集群中的节点发送数据命令了 
    - ⏱ 2022-02-18 10:40:39 

- 📌 接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己 
    - ⏱ 2022-02-18 16:28:41 

- 📌 ❑如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。❑如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向（redirect）至正确的节点，并再次发送之前想要执行的命令 
    - ⏱ 2022-02-18 16:28:49 

- 📌 如果clusterState.slots[i]等于clusterState.myself，那么说明槽i由当前节点负责，节点可以执行客户端发送的命令 
    - ⏱ 2022-02-18 16:30:04 
## 17.4 重新分片


- 📌 重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理命令请求 
    - ⏱ 2022-02-18 16:30:52 
## 17.5 ASK错误


- 📌 命令要处理的数据库键恰好就属于正在被迁移的槽时 
    - ⏱ 2022-02-18 16:31:56 
## 17.8 重点回顾


- 📌 ❑如果节点A正在迁移槽i至节点B，那么当节点A没能在自己的数据库中找到命令指定的数据库键时，节点A会向客户端返回一个ASK错误，指引客户端到节点B继续查找指定的数据库键。 
    - ⏱ 2022-02-18 16:33:51 

- 📌 而ASK错误只是两个节点在迁移槽的过程中使用的一种临时措施 
    - ⏱ 2022-02-18 16:34:11 

- 📌 集群中的节点通过发送和接收消息来进行通信，常见的消息包括MEET、PING、PONG、PUBLISH、FAIL五种。 
    - ⏱ 2022-02-18 16:34:26 
# 读书笔记

## 9.4 设置键的生存时间或过期时间

### 划线评论
- 📌 PERSIST命令可以移除一个键的过期时间： 
    - 💭 从dict移除键值

    - ⏱ 2021-12-20 15:28:00

### 划线评论
- 📌 [插图] 
    - 💭 给dict新增键值

    - ⏱ 2021-12-20 15:27:13

### 划线评论
- 📌 redisDb结构 
    - 💭 每个redisDb结构代表一个数据库
    - ⏱ 2021-12-20 15:22:31

### 划线评论
- 📌 ❑过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）。❑过期字典的值是一个long long类型的整数，这个整数保存了键所指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳。 
    - 💭 过期字典也是键值形式，键是指向数据库中某个键对象的指针，值是这个键对象过期的时间（UNIX时间戳）
    - ⏱ 2021-12-20 15:18:14
   
## 9.5 过期键删除策略

### 划线评论
- 📌 惰性删除策略对CPU时间来说是最友好的 
    - 💭 删除操作进行得次数最少。
    - ⏱ 2021-12-20 15:59:46

### 划线评论
- 📌 定时删除策略对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。 
    - 💭 删除得最即时

    - ⏱ 2021-12-20 15:38:29
   
## 第10章 RDB持久化

### 划线评论
- 📌 RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘里面，避免数据意外丢失。 
    - 💭 RDB持久化：把内存里的数据保存到磁盘。
    - ⏱ 2022-01-01 19:21:53
   
## 第11章 AOF持久化

### 划线评论
- 📌 RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的 
    - 💭 RDB记录数据库键值对，AOF记录写命令

    - ⏱ 2022-01-06 14:52:51
   
## 11.3 AOF重写

### 划线评论
- 📌 因为子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。 
    - 💭 同步问题
    - ⏱ 2022-01-08 20:13:43

### 划线评论
- 📌 子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。❑子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。 
    - 💭 1.不被阻塞
2.数据安全

    - ⏱ 2022-01-08 20:13:07

### 划线评论
- 📌 直接从数据库中读取键list的值，然后用一条RPUSH list"C""D""E""F""G"命令来代替保存在AOF文件中的六条命令，这样就可以将保存list键所需的命令从六条减少为一条了。 
    - 💭 从数据库状态反推写命令实现
    - ⏱ 2022-01-08 20:08:52
   
## 15.1 旧版复制功能的实现

### 划线评论
- 📌 从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：1）从服务器向主服务器发送SYNC命令。2）收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。3）当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态。4）主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。 
    - 💭 RDB与AOF结合，同时保证速度准确度
    - ⏱ 2022-01-26 14:11:35
   
## 16.1 启动并初始化Sentinel

### 划线评论
- 📌 每个sentinelRedisInstance结构（后面简称“实例结构”）代表一个被Sentinel监视的Redis服务器实例（instance），这个实例可以是主服务器、从服务器，或者另外一个Sentine 
    - 💭 sentinel也可以监视sentinel！
    - ⏱ 2022-02-14 16:05:02
   
## 16.2 获取主服务器信息

### 划线评论
- 📌 Sentinel无须用户提供从服务器的地址信息，就可以自动发现从服务器。 
    - 💭 是通过主服务器得到的
    - ⏱ 2022-02-14 16:10:17
   
## 16.8 选举领头Sentinel

### 划线评论
- 📌 可能会有某个Sentinel的SENTINEL is-master-down-by-addr命令比起其他Sentinel发送的相同命令都更快到达，并最终胜出领头Sentinel的选举，然后这个领头Sentinel就可以开始对主服务器执行故障转移操作了。 
    - 💭 哇，那就是谁先抢到，谁就是领头sentinel
    - ⏱ 2022-02-17 21:13:54
   
## 16.9 故障转移

### 划线评论
- 📌 SLAVEOF no one命令，将这个从服务器转换为主服务器。 
    - 💭 slave of no one!
    - ⏱ 2022-02-17 21:15:17
   
## 17.1 节点

### 划线评论
- 📌 握手过程 
    - 💭 也是三次握手
    - ⏱ 2022-02-18 09:20:10
   
## 17.2 槽指派

### 划线评论
- 📌 为了知道槽i是否已经被指派，或者槽i被指派给了哪个节 
    - 💭 以o(1)的复杂度得到槽的指派信息
    - ⏱ 2022-02-18 10:16:15
   
# 本书评论
