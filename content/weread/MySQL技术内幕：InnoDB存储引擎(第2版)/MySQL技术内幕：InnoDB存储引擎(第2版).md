---
doc_type: weread-highlights-reviews
bookId: "603246"
author: 姜承尧
cover: https://cdn.weread.qq.com/weread/cover/55/YueWen_603246/t7_YueWen_603246.jpg
reviewCount: 1
noteCount: 36
isbn: 9787111422068
category: 计算机-数据库
lastReadDate: 2021-05-17
---
# 元数据
> [!abstract] MySQL技术内幕：InnoDB存储引擎(第2版)
> - ![ MySQL技术内幕：InnoDB存储引擎(第2版)|200](https://cdn.weread.qq.com/weread/cover/55/YueWen_603246/t7_YueWen_603246.jpg)
> - 书名： MySQL技术内幕：InnoDB存储引擎(第2版)
> - 作者： 姜承尧
> - 简介： 本书从源代码的角度深度解析了InnoDB的体系结构、实现原理、工作机制，并给出了大量最佳实践，能帮助你系统而深入地掌握InnoDB，更重要的是，它能为你设计管理高性能、高可用的数据库系统提供绝佳的指导。
> - 出版时间 2013-05-30 00:00:00
> - ISBN： 9787111422068
> - 分类： 计算机-数据库
> - 出版社： 机械工业出版社

# 高亮划线

## 第1章 MySQL体系结构和存储引擎


- 📌 插件式的表存储引擎 
    - ⏱ 2021-05-16 00:40:05 

- 📌 存储引擎是基于表的，而不是数据库 
    - ⏱ 2021-05-16 00:40:27 

- 📌 InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用 
    - ⏱ 2021-05-16 00:42:59 

- 📌 行锁设计、支持外键，并支持类似于Oracle的非锁定读，即默认读取操作不会产生锁 
    - ⏱ 2021-05-16 00:43:15 

- 📌 InnoDB存储引擎采用了聚集（clustered）的方式，因此每张表的存储都是按主键的顺序进行存放 
    - ⏱ 2021-05-16 00:45:21 

- 📌 MyISAM存储引擎不支持事务、表锁设计，支持全文索引 
    - ⏱ 2021-05-16 00:45:45 

- 📌 它的缓冲池只缓存（cache）索引文件，而不缓冲数据文件，这点和大多数的数据库都非常不同 
    - ⏱ 2021-05-16 00:46:20 

- 📌 MYD用来存放数据文件，MYI用来存放索引文件 
    - ⏱ 2021-05-16 00:46:30 

- 📌 Memory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。 
    - ⏱ 2021-05-16 00:47:20 

- 📌 Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的 
    - ⏱ 2021-05-16 00:47:37 

- 📌 MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于Memory存储引擎表的容量设置，又或者中间结果含有TEXT或BLOB列类型字段，则MySQL数据库会把其转换到MyISAM存储引擎表而存放到磁盘中。之前提到MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。 
    - ⏱ 2021-05-16 00:48:00 

- 📌 MyISAM、InnoDB（1.2版本）和Sphinx存储引擎都支持全文索引。 
    - ⏱ 2021-05-16 00:48:38 
## 第2章 InnoDB存储引擎


- 📌 Master Thread是一个非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲（INSERTBUFFER）、UNDO页的回收等 
    - ⏱ 2021-05-16 00:59:07 

- 📌 IO Thread的工作主要是负责这些IO请求的回调（callback）处理 
    - ⏱ 2021-05-16 01:06:32 

- 📌 其作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成 
    - ⏱ 2021-05-16 01:08:04 

- 📌 缓冲池简单来说就是一块内存区域，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，这个过程称为将页“FIX”在缓冲池中。下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。 
    - ⏱ 2021-05-16 01:09:31 

- 📌 缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲（insert buffer）、自适应哈希索引（adaptive hash index）、InnoDB存储的锁信息（lock info）、数据字典信息（data dictionary）等。不能简单地认为，缓冲池只是缓存索引页和数据页，它们只是占缓冲池很大的一部分而已。图2-2很好地显示了InnoDB存储引擎中内存的结构情况。 
    - ⏱ 2021-05-16 01:11:32 

- 📌 即最频繁使用的页在LRU列表的前端，而最少使用的页在LRU列表的尾端。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。 
    - ⏱ 2021-05-16 01:12:35 

- 📌 虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置。这个算法在InnoDB存储引擎下称为midpoint insertionstrategy。在默认配置下，该位置在LRU列表长度的5/8处 
    - ⏱ 2021-05-16 01:13:37 

- 📌 这是因为若直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作为索引或数据的扫描操作。这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘。 
    - ⏱ 2021-05-16 01:15:09 

- 📌 表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端 
    - ⏱ 2021-05-16 01:15:39 

- 📌 下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。□ Master Thread每一秒将重做日志缓冲刷新到重做日志文件；□ 每个事务提交时会将重做日志缓冲刷新到重做日志文件；□ 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。 
    - ⏱ 2021-05-16 01:28:15 

- 📌 即当事务提交时，先写重做日志，再修改页 
    - ⏱ 2021-05-16 01:30:19 

- 📌 当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是事务ACID中D（Durability持久性）的要求。 
    - ⏱ 2021-05-16 01:30:34 

- 📌 □ 缩短数据库的恢复时间；□ 缓冲池不够用时，将脏页刷新到磁盘；□ 重做日志不可用时，刷新脏页。当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。故数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短了恢复的时间。 
    - ⏱ 2021-05-16 01:32:01 

- 📌 即使某个事务还没有提交，InnoDB存储引擎仍然每秒会将重做日志缓冲中的内容刷新到重做日志文件。这一点是必须要知道的，因为这可以很好地解释为什么再大的事务提交（commit）的时间也是很短的。 
    - ⏱ 2021-05-16 12:35:15 

- 📌 InnoDB存储引擎的关键特性包括：□ 插入缓冲（Insert Buffer）□ 两次写（Double Write）□ 自适应哈希索引（Adaptive Hash Index）□ 异步IO（Async IO）□ 刷新邻接页（Flush Neighbor Page） 
    - ⏱ 2021-05-16 12:40:24 

- 📌 聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中，好似欺骗 
    - ⏱ 2021-05-17 09:08:02 

- 📌 在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite 
    - ⏱ 2021-05-17 09:10:40 

- 📌 doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中连续的128个页，即2个区（extent），大小同样为2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在这个过程中，因为doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件中，此时的写入则是离散的 
    - ⏱ 2021-05-17 09:12:44 

- 📌 哈希（hash）是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为O（1），即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高度，在生产环境中，B+树的高度一般为3～4层，故需要3～4次的查询。 
    - ⏱ 2021-05-17 09:13:43 

- 📌 InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI 
    - ⏱ 2021-05-17 09:13:59 

- 📌 AHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引页，其访问模式可以是以下情况：□ WHERE a=xxx□ WHERE a=xxx and b=xxx访问模式一样指的是查询的条件一样，若交替进行上述两种查询，那么InonDB存储引擎不会对该页构造AHI。此外AHI还有如下的要求：□ 以该模式访问了100次□ 页通过该模式访问了N次，其中N=页中记录*1/16 
    - ⏱ 2021-05-17 09:14:42 

- 📌 即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作 
    - ⏱ 2021-05-17 09:19:32 
 

- 📌 AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能 
    - ⏱ 2021-05-17 09:20:47 
# 读书笔记

## 第2章 InnoDB存储引擎

### 划线评论
- 📌 但是如果用户发出的是一条索引扫描的查询，那么这条SQL查询语句可能需要扫描多个索引页，也就是需要进行多次的IO操作。在每扫描一个页并等待其完成后再进行下一次的扫描，这是没有必要的。用户可以在发出一个IO请求后立即再发出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。 
    - 💭 解释了什么是异步

    - ⏱ 2021-05-17 09:21:05
   
# 本书评论
