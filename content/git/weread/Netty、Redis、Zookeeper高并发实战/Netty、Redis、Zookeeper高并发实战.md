---
doc_type: weread-highlights-reviews
bookId: "26174369"
author: 尼恩
cover: https://cdn.weread.qq.com/weread/cover/4/YueWen_26174369/t7_YueWen_26174369.jpg
reviewCount: 6
noteCount: 38
isbn: 9787111632900
category: 计算机-编程设计
lastReadDate: 2022-01-30
---
# 元数据
> [!abstract] Netty、Redis、Zookeeper高并发实战
> - ![ Netty、Redis、Zookeeper高并发实战|200](https://cdn.weread.qq.com/weread/cover/4/YueWen_26174369/t7_YueWen_26174369.jpg)
> - 书名： Netty、Redis、Zookeeper高并发实战
> - 作者： 尼恩
> - 简介： 本书从操作系统底层的IO原理入手，同时提供高性能开发的实战案例，是一本高并发Java编程应用基础图书。 本书共分为12章。第1~5章为高并发基础，浅显易懂地剖析高并发IO的底层原理，细致地讲解Reactor高性能模式，图文并茂地介绍Java异步回调模式。这些原理方面的基础知识非常重要，会为读者打下坚实的基础，也是日常开发Java后台应用时解决实际问题的金钥匙。第6~9章为Netty原理和实战，是本书的重中之重，主要介绍高性能通信框架Netty、Netty的重要组件、单体IM的实战设计和模块实现。第10~12章对ZooKeeper、Curator API、Redis、Jedis API的使用进行详尽的说明，以提升读者设计和开发高并发、可扩展系统的能力。本书兼具基础知识和实战案例，既可作为对Java NIO、高性能IO、高并发编程感兴趣的大专院校学生和初、中级Java工程师的学习参考书，也可作为在生产项目中需要用到Netty、Redis、ZooKeeper三大框架的架构师或项目人员的使用参考书。
> - 出版时间 2019-08-01 00:00:00
> - ISBN： 9787111632900
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社

# 高亮划线

## 1.1 Netty为何这么火


- 📌 Netty的所有IO操作都是异步非阻塞 
    - ⏱ 2022-01-28 20:43:02 
## 2.1 IO读写的基础原理


- 📌 缓冲区 
    - ⏱ 2022-01-28 20:47:23 

- 📌 调用操作系统的read，是把数据从内核缓冲区复制到进程缓冲区；而write系统调用，是把数据从进程缓冲区复制到内核缓冲区。 
    - ⏱ 2022-01-28 20:47:33 

- 📌 上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到上层应用的缓冲区（进程缓冲区）；上层应用使用write系统调用时，仅仅把数据从进程缓冲区复制到内核缓冲区 
    - ⏱ 2022-01-28 20:48:35 
## 2.2 四种主要的IO模型


- 📌 阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间执行用户的操作 
    - ⏱ 2022-01-28 20:54:39 

- 📌 阻塞指的是用户空间程序的执行状态 
    - ⏱ 2022-01-28 20:55:00 

- 📌 同步IO，是一种用户空间与内核空间的IO发起方式 
    - ⏱ 2022-01-28 20:55:27 

- 📌 同步IO是指用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指系统内核是主动发起IO请求的一方，用户空间的线程是被动接受方 
    - ⏱ 2022-01-28 20:55:54 

- 📌 非阻塞IO，指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间执行用户的操作 
    - ⏱ 2022-01-28 21:13:00 

- 📌 与此同时内核会立即返回给用户一个状态值。 
    - ⏱ 2022-01-28 21:13:05 

- 📌 阻塞是指用户空间（调用线程）一直在等待，而不能干别的事情；非阻塞是指用户空间（调用线程）拿到内核返回的状态值就返回自己的空间，IO操作可以干就干，不可以干，就去干别的事情。 
    - ⏱ 2022-01-28 21:13:21 
 

- 📌 异步IO，指的是用户空间与内核空间的调用方式反过来。用户空间的线程变成被动接受者，而内核空间成了主动调用 
    - ⏱ 2022-01-28 21:24:48 
 
 
 

- 📌 核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据，它会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到的用户缓冲区的字节数 
    - ⏱ 2022-01-28 21:46:44 

- 📌 应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好，就继续轮询，直到完成IO系统调用为止 
    - ⏱ 2022-01-28 21:46:54 

- 📌 Java的NIO（New IO），对应的不是四种基础IO模型中的NIO（None Blocking IO）模型，而是另外的一种模型，叫作IO多路复用模型（IO Multiplexing）。 
    - ⏱ 2022-01-28 21:48:20 

- 📌 一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写），内核能够将就绪的状态返回给应用程序。随后，应用程序根据就绪的状态，进行相应的IO系统调用。 
    - ⏱ 2022-01-28 21:50:15 

- 📌 1）选择器注册。在这种模式中，首先，将需要read操作的目标socket网络连接，提前注册到select/epoll选择器中，Java中对应的选择器类是Selector类。然后，才可以开启整个IO多路复用模型的轮询流程。（2）就绪状态的轮询。通过选择器的查询方法，查询注册过的所有socket连接的就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好了，内核缓冲区有数据（就绪）了，内核就将该socket加入到就绪的列表中。当用户进程调用了select查询方法，那么整个线程会被阻塞掉。 
    - ⏱ 2022-01-28 21:58:52 
 

- 📌 IO。都需要在读写事件就绪后，由系统调用本身负责进行读写，也就是说这个读写过程是阻塞的。 
    - ⏱ 2022-01-28 21:57:28 

- 📌 （3）内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。 
    - ⏱ 2022-01-28 22:11:17 

- 📌 Netty框架，使用的就是IO多路复用模型 
    - ⏱ 2022-01-28 22:11:56 
## 2.3 通过合理配置来支持百万级并发连接


- 📌 ulimit只能作为临时修改，系统重启后，句柄数量又会恢复为默认值。 
    - ⏱ 2022-01-28 22:17:10 
## 3.1 Java NIO简介


- 📌 · Channel（通道）· Buffer（缓冲区）· Selector（选择器） 
    - ⏱ 2022-01-28 22:19:46 

- 📌 IO多路复用模型 
    - ⏱ 2022-01-28 22:21:21 

- 📌 OIO是面向流（Stream Oriented）的，NIO是面向缓冲区（BufferOriented）的。 
    - ⏱ 2022-01-28 22:21:54 

- 📌 指的是一个进程/线程可以同时监视多个文件描述符（一个网络连接，操作系统底层使用一个文件描述符来表示），一旦其中的一个或者多个文件描述符可读或者可写，系统内核就通知该进程/线程。 
    - ⏱ 2022-01-28 22:32:26 

- 📌 首先把通道注册到选择器中，然后通过选择器内部的机制，可以查询（select）这些注册的通道是否有已经就绪的IO事件 
    - ⏱ 2022-01-28 22:32:42 
## 3.2 详解NIO Buffer类及其属性


- 📌 Buffer类是一个非线程安全类 
    - ⏱ 2022-01-28 22:36:58 

- 📌 capacity容量不是指内存块byte[]数组的字节的数量。capacity容量指的是写入的数据对象的数量 
    - ⏱ 2022-01-28 22:39:47 

- 📌 ）在刚进入到写模式时，position值为0，表示当前的写入位置为从头开始。（2）每当一个数据写到缓冲区之后，position会向后移动到下一个可写的位置。（3）初始的position值为0，最大可写值position为limit-1。当position值达到limit时，缓冲区就已经无空间可写 
    - ⏱ 2022-01-28 22:40:11 

- 📌 1）当缓冲区刚开始进入到读模式时，position会被重置为0。（2）当从缓冲区读取时，也是从position位置开始读。读取数据后，position向前移动到下一个可读的位置。（3）position最大的值为最大可读上限limit，当position达到limit时，表明缓冲区已经无数据可读。 
    - ⏱ 2022-01-28 22:40:21 

- 📌 [插图] 
    - ⏱ 2022-01-28 22:42:24 
## 3.5 详解NIO Selector选择器


- 📌 数据总是从通道读到缓冲区内，或者从缓冲区写入到通道中 
    - ⏱ 2022-01-29 19:07:18 

- 📌 通道和选择器之间的关系，通过register（注册）的方式完成。调用通道的Channel.register（Selector sel, int ops）方法，可以将通道实例注册到一个选择器中 
    - ⏱ 2022-01-30 12:44:00 
# 读书笔记

## 2.2 四种主要的IO模型

### 划线评论
- 📌 和NIO模型相似，多路复用IO也需要轮询。负责select/epoll状态查询调用的线程，需要不断地进行select/epoll轮询，查找出达到IO操作就绪的socket连接 
    - 💭 把nio中用户进程的轮询任务抽离，由select线程执行
    - ⏱ 2022-01-28 21:56:28

### 划线评论
- 📌 IO多路复用模型 
    - 💭 为了解决用户进程轮询的问题
    - ⏱ 2022-01-28 21:49:35

### 划线评论
- 📌 在内核缓冲区中有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。 
    - 💭 同步
    - ⏱ 2022-01-28 21:41:47

### 划线评论
- 📌 在内核缓冲区中没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。 
    - 💭 非阻塞
    - ⏱ 2022-01-28 21:41:31

### 划线评论
- 📌 用户空间的线程向内核空间注册了各种IO事件的回调函数，由内核去主动调用。 
    - 💭 顾客去店里吃面
同步：顾客询问老板，面好了没
异步：老板做好面，通知顾客
    - ⏱ 2022-01-28 21:26:19

### 划线评论
- 📌 异步阻塞IO, Java中的Selector选择器和Linux中的epoll都是这种模型 
    - 💭 io多路复用，又称异步阻塞io，应用有selector\epoll...
    - ⏱ 2022-01-28 21:23:51
   
# 本书评论
